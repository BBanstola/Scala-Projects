// Core Part about a really dumb investment strategy
//===================================================

object CW6b {



  val blchip_portfolio = List("GOOG", "AAPL", "MSFT", "IBM", "FB", "AMZN", "BIDU")
  val rstate_portfolio = List("PLD", "PSA", "AMT", "AIV", "AVB", "BXP", "CCI",
    "DLR", "EQIX", "EQR", "ESS", "EXR", "FRT", "HCP")


  // (1) The function below takes a stock symbol and a year as arguments.
  //     It should read the corresponding CSV-file and then extract the January
  //     data from the given year. The data should be collected in a list of
  //     strings (one entry for each line in the CSV-file).

  import io.Source._
  import scala.util._

  //def get_january_data(symbol: String, year: Int) : List[String] = ...

  def get_january_data(symbol: String, year: Int) : List[String] = {
    Try(Some(
      fromFile(symbol ++ ".csv").getLines.toList.filter(janFilter(_ , year.toString)))
    ).getOrElse(None).toList.flatten
  }

  def janFilter(line: String, year: String):Boolean = {
    if(!line.isEmpty){
      if( line.split("-")(0) == year && line.split("-")(1) == "01") true else false
    }else false
  }

  /*
  def get_jan(symbol: String, year: Int) : List[String] ={
    val Pattern = s"$year-(\\d+)-(\\d+),(.*)".r
    for {
      Pattern("01", day, price) <- fromFile("D:/Part6/Part6/" ++ symbol ++ ".csv").getLines             // replace with the file location
    } yield day
  }.toList
  */


  //get_january_data("AAPL",1981)

  // (2) From the output of the get_january_data function, the next function
  //     should extract the first line (if it exists) and the corresponding
  //     first trading price in that year with type Option[Double]. If no line
  //     is generated by get_january_data then the result is None; and Some if
  //     there is a price.


  //def get_first_price(symbol: String, year: Int) : Option[Double] = ...

  def get_first_price(symbol: String, year: Int) : Option[Double] =
    Try(Some(get_january_data(symbol, year).head.split(",")(1).toDouble)).getOrElse(None)

  //get_first_price("AAPL",1995)

  // (3) Complete the function below that obtains all first prices
  //     for the stock symbols from a portfolio (list of strings) and
  //     for the given range of years. The inner lists are for the
  //     stock symbols and the outer list for the years.


  //def get_prices(portfolio: List[String], years: Range) : List[List[Option[Double]]] = ...

  def get_prices(portfolio: List[String], years: Range) : List[List[Option[Double]]] = {
    for( y <- years.toList) yield{
      for(x <- portfolio)  yield{get_first_price(x , y)}
    }
  }

  //val p = get_prices(List("GOOG", "AAPL"), 2010 to 2012)

  // (4) The function below calculates the change factor (delta) between
  //     a price in year n and a price in year n + 1.

  //def get_delta(price_old: Option[Double], price_new: Option[Double]) : Option[Double] = ...

  def get_delta(price_old: Option[Double], price_new: Option[Double]) : Option[Double] ={
    if(price_new.isDefined && price_old.isDefined) Option((price_new.get - price_old.get)/price_old.get) else None
  }

  // (5) The next function calculates all change factors for all prices (from a
  //     portfolio). The input to this function are the nested lists created by
  //     get_prices above.

  //def get_deltas(data: List[List[Option[Double]]]) :  List[List[Option[Double]]] = ...

  def get_deltas(data: List[List[Option[Double]]]) :  List[List[Option[Double]]] ={
    data.tail.map( year => {
      year.map( company_price => get_delta( data(data.indexOf(year) - 1)(year.indexOf(company_price)), company_price))})
  }

  //val d = get_deltas(p)

  // (6) Write a function that given change factors, a starting balance and an index,
  //     calculates the yearly yield, i.e. new balance, according to our dumb investment
  //     strategy. Index points to a year in the data list.

  //def yearly_yield(data: List[List[Option[Double]]], balance: Long, index: Int) : Long = ...

  def yearly_yield(data: List[List[Option[Double]]], balance: Long, index: Int) : Long ={
    val year = data(index).flatten
    val amount:Long = balance/year.length

    balance.toLong + year.foldLeft(0.0){case (acc, d) => acc + amount * d}.toLong
    //((year.fold(0.0)(_+_)*amount)+balance).round
  }

  /*
  yearly_yield( get_deltas( get_prices (List("GOOG", "AAPL"), (2010 to 2012))), 100, 0)
  yearly_yield( get_deltas( get_prices (rstate_portfolio, ( 1978 to 2018))), 100, 0)
  */

  // (7) Write a function compound_yield that calculates the overall balance for a
  //     range of years where in each year the yearly profit is compounded to the new
  //     balances and then re-invested into our portfolio. For this use the function and
  //     results generated under (6). The function investment calls compound_yield
  //     with the appropriate deltas and the first index.

  //def compound_yield(data: List[List[Option[Double]]], balance: Long, index: Int) : Long = ...

  def compound_yield(data: List[List[Option[Double]]], balance: Long, index: Int) : Long = (index >= data.length) match {
    case true => balance
    case _ => {
      val nb = yearly_yield(data, balance, index)
      compound_yield(data, nb, index+1)
    }
  }
  //(0 until index).foldLeft(balance){case (nb, idx) => yearly_yield(data, nb, idx)}

  //def investment(portfolio: List[String], years: Range, start_balance: Long) : Long = ...

  def investment(portfolio: List[String], years: Range, start_balance: Long) : Long ={
    val getData = get_deltas(get_prices(portfolio, years))
    //compound_yield(getData, start_balance, years.end - years.start)
    compound_yield(getData, start_balance, 0)
  }

  //Test cases for the two portfolios given above
  /*
  investment(rstate_portfolio, 1978 to 2019, 100)
  investment(blchip_portfolio, 1978 to 2019, 100)

  println("Real data: " + investment(rstate_portfolio, 1978 to 2019, 100))
  println("Blue data: " + investment(blchip_portfolio, 1978 to 2019, 100))
  get_deltas(get_prices(rstate_portfolio, 1978 to 2018)).length
  */

}
